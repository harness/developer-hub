---
title: FME Redux SDK
sidebar_label: Redux SDK
description: Redux developer reference for working with FME on the client and server side
---

import DocCardList from '@theme/DocCardList';

This guide provides detailed information about our Redux SDK. This library is built on top of our regular [JavaScript SDK](https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK) to ease the integration in applications using Redux by providing a [reducer](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#reducers) to manage the Split-related state, a set of [actions](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#actions) that you can use to interact with the SDK, [selectors](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#selectors) to easily get Split-desired data, and helper functions to access some of the underlying SDK functionality to support all use cases.

Taking advantage of our JavaScript SDK being isomorphic, we also support [SSR](https://redux.js.org/usage/server-rendering) by using the underlying [SDK in Node.js](https://help.split.io/hc/en-us/articles/360020564931-Node-js-SDK)

This library also offers some extra features for users of React that are using [react-redux](https://github.com/reduxjs/react-redux) bindings.

All of our SDKs are open source. Go to our [Redux SDK GitHub repository](https://github.com/splitio/redux-client) to see the source code.

:::info[Migrating from v1.x to v2.x]
Refer to the [migration guide](https://github.com/splitio/redux-client/blob/development/MIGRATION-GUIDE.md) for information on upgrading to v2.x.
:::

## Language support and requirements

This SDK is compatible with Redux v3 and later. It requires the [redux-thunk](https://github.com/reduxjs/redux-thunk) package to be installed on the app, which is included by default if your project is using the [Redux Toolkit](https://redux-toolkit.js.org/). This means you don't need to run `npm install redux-thunk` if Redux Toolkit is already installed.

For `react-redux` users, the SDK supports its v4 and later.

In SSR setups, our library code is prepared to run in Node.js 14+.

## Initialization
 
Set up Split in your code base in two steps.

### 1. Import the SDK into your project

The SDK is published using `npm`, so it's fully integrated with your workflow. You should be able to add it with `yarn` too.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
  values={[
    {label: 'NPM', value: 'npm'},
    {label: 'Yarn', value: 'yarn'}
  ]}>
  <TabItem value="npm">
```bash
npm install --save @splitsoftware/splitio-redux
```
  </TabItem>
  <TabItem value="yarn">
```bash
yarn add @splitsoftware/splitio-redux
```
  </TabItem>
</Tabs>

### 2. Integrate the SDK in your application

You need to combine the Split reducer with yours when creating your store and use the `initSplitSdk` action creator, which returns a thunk, to set things in motion. You can use the [combineReducers](https://redux.js.org/api/combinereducers#combinereducersreducers) function of Redux on the `splitio` key. You can mount it at a different key but might require some extra code if you use the specific functionality for [react-redux](#advanced-usage-with-react--redux).

For the client side, the Redux documentation [recommends](https://redux.js.org/introduction/getting-started#basic-example) creating a single store to be used as the source of truth for your state. This is where we'll plug in the Split reducer.

For Server Side Rendering, the Redux documentation [suggests](https://redux.js.org/usage/server-rendering#handling-the-request) creating a store per request, which is why we provide a function to create stores, where each instance will include the Split reducer.

<Tabs
  values={[
    {label: 'Client Side with Redux Toolkit', value: 'toolkit'},
    {label: 'Client Side with Redux', value: 'redux'},
    {label: 'Server Side', value: 'serverside'},
  ]}>
  <TabItem value="toolkit">
```javascript
import { configureStore, combineReducers } from '@reduxjs/toolkit';
import { splitReducer, initSplitSdk } from '@splitsoftware/splitio-redux';

const sdkBrowserConfig = {
  core: {
    authorizationKey: 'YOUR_SDK_KEY',
    // key represents your internal user id, or the account id that 
    // the user belongs to. 
    // This could also be a cookie you generate for anonymous users.
    key: 'key'
  }
};

// Create the Redux Store
const store = configureStore(
  combineReducers({
    splitio: splitReducer,
    ... // Combine Split reducer with your own reducers
  }),
  // Split SDK requires thunk middleware, which is included by default by Redux Toolkit
);

// Initialize the SDK by calling the initSplitSdk and passing the config in the parameters object.
store.dispatch(initSplitSdk({ config: sdkBrowserConfig }));

export default store;
```
  </TabItem>
  <TabItem value="redux">
```javascript
import { createStore, applyMiddleware, combineReducers } from 'redux';
import thunk from 'redux-thunk'; // Requirement for asynchronous actions
import { splitReducer, initSplitSdk } from '@splitsoftware/splitio-redux';

const sdkBrowserConfig = {
  core: {
    authorizationKey: 'YOUR_SDK_KEY',
    // key represents your internal user id, or the account id that 
    // the user belongs to. 
    // This could also be a cookie you generate for anonymous users.
    key: 'key'
  }
};

// Create the Redux Store
const store = createStore(
  combineReducers({
    splitio: splitReducer,
    ... // Combine Split reducer with your own reducers
  }),
  // Add thunk middleware, used by Split SDK async actions
  applyMiddleware(thunk)
);

// Initialize the SDK by calling the initSplitSdk and passing the config in the parameters object.
store.dispatch(initSplitSdk({ config: sdkBrowserConfig }));

export default store;
```
  </TabItem>
  <TabItem value="serverside">
```javascript
import { createStore, applyMiddleware, combineReducers } from 'redux';
import thunk from 'redux-thunk'; // Requirement for asynchronous actions
import { splitReducer, initSplitSdk } from '@splitsoftware/splitio-redux';

const sdkNodeConfig = {
  core: {
    authorizationKey: 'YOUR_SDK_KEY'
  }
};
/**
 * initSplitSdk should be called only once, to keep a single Split factory instance.
 * The returned action is dispatched each time a new store is created, to update 
 * the Split status at the state. 
 */
const initSplitSdkAction = initSplitSdk({ config: sdkNodeConfig });

const reducers = combineReducers({
  splitio: splitReducer,
  ... // Combine Split reducer with your own reducers
});

export default function storeCreator() {
  // Pass the reducers combined, including the splitReducer to each new store you create.
  const store = createStore(reducers, applyMiddleware(thunk));
  // Dispatch the initSplitSdk returned action the new store instance.
  store.dispatch(initSplitSdkAction);

  return store;
}
```
  </TabItem>
</Tabs>

:::info[Notice for TypeScript]
With the SDK package on NPM, you get the SplitIO namespace, which contains useful types and interfaces.

Feel free to dive into the declaration files if IntelliSense is not enough!
:::

We recommend instantiating the Split factory once as a singleton and reusing it throughout your application.

Configure the SDK with the SDK key for the Split environment that you would like to access. The SDK key is available in the Split UI, on your Admin settings page, API keys section. Select a client-side SDK API key. This is a special type of API token with limited privileges for use in browsers or mobile clients. See [API keys](https://help.split.io/hc/en-us/articles/360019916211) to learn more.

## Using the SDK

The Split SDK via its reducer keeps a portion of the store state up to date. The Split state data adheres to the following schema:

```javascript title="Split state shape"
{
  // 'splitio' is the key where the Split reducer is expected to be mounted.
  'splitio': {
    // The following properties indicate the current status of the SDK main client (the one bound to the key provided in the config).
    'isReady': true, // boolean flag indicating if the SDK is ready
    'isReadyFromCache': false, // boolean flag indicating if the SDK is ready from cache
    'isTimedout': false, // boolean indicating if the SDK is in a timed out state. Note: it will get ready eventually unless it's misconfigured
    'hasTimedout': false, // boolean indicating if the SDK has ever been in a timed out state
    'isDestroyed': false, // boolean indicating if the SDK has been destroyed. Read more in the shutdown section
    'lastUpdate': 56789592012, // timestamp of the last SDK state change (either timed out, got ready, destroyed or processed an update from the cloud)

    /** 
     * The 'treatments' property contains the evaluations of feature flags.
     * Each evaluation consist of TreatmentResult objects associated to the key used on the evaluation and the feature flag name.
     * We recommend that you use the provided selector functions for ease of consumption.
     */
    'treatments': { 
      'feature_flag_name_1': {
        'key': {
          'treatment': 'on',
          'config': "{'copy': 'better copy', 'color': 'red'}"
        }
      },
      'feature_flag_2': {
        'key': {
          'treatment': 'off',
          'config': null
        }
      }
    },
    /**
     * The 'status' property contains the status of the non-default clients, i.e., the ones that are not bound to the key provided in the config.
     */
    'status': {
      'key': {
        'isReady': true, 'isReadyFromCache': false, 'isTimedout': false, 'hasTimedout': false, 'isDestroyed': false, 'lastUpdate': 56789592012
      }
    }
  }
}
```
 
### Basic use

When the SDK is initialized, it starts background tasks to update an in-memory cache with small amounts of data fetched from Split servers. This process can take up to a few hundred milliseconds depending on the size of data. If the SDK is asked to evaluate a feature flag while it's in this intermediate state, it may not have the necessary data and will queue the evaluation until it is ready.

To make sure the SDK is fully loaded before using a treatment, wait until the SDK client is ready. You can check SDK readiness in one of the following ways:

 - Provide an `onReady` callback as a parameter to the `initSplitSdk` function.
 - Check the `isReady` property of the `splitio` Redux state.
 - Check if the `initSplitSdk` returned promise is resolved.
 - Check the `isReady` property from the `splitio` selector result.

After the SDK is ready, you can use the SDK to evaluate feature flags.

<Tabs
  values={[
    {label: 'Providing onReady callback', value: 'onready'},
    {label: 'Using isReady flag on the state', value: 'state'},
    {label: 'Using initSplitSdk returned promise', value: 'promise'},
    {label: 'Using isReady property from the selector result', value: 'selector'},
  ]}>
  <TabItem value="onready">
```javascript
import { initSplitSdk } from '@splitsoftware/splitio-redux';

function onReadyCallback() {
  // Use the SDK now that it is ready to properly evaluate.
}

// Along with the config, you can provide a callback to be executed once the SDK is ready, to handle accordingly.
store.dispatch(initSplitSdk({ 
  config: sdkConfig,
  onReady: onReadyCallback
}));
```
  </TabItem>
  <TabItem value="state">
```javascript
// You should have already initialized the SDK.
let isSplitReady = false;

const handleChange = () => {
  const isReadyFlag = store.getState().splitio.isReady;

  if (isReadyFlag) {
    // Keep in mind that the store subscription will be triggered any time an action is dispatched, 
    // and some part of the state tree may potentially have changed.
    isSplitReady = true;
    
    // Use the SDK now that it is ready to properly evaluate.
  }
}

// Note: If you're using react-redux you could do this via mapStateToProps. Read more below!
store.subscribe(handleChange);
```
  </TabItem>
  <TabItem value="promise">
```javascript
import { initSplitSdk } from '@splitsoftware/splitio-redux';

function onReadyCallback() {
  // Use the SDK now that it is ready to properly evaluate.
}

// initSplitSdk action creator would return a promise. If the SDK is ready already the promise will be resolved by this time.
store.dispatch(initSplitSdk({ config: sdkConfig })).then(onReadyCallback);
```
  </TabItem>
  <TabItem value="selector">
```javascript
import { initSplitSdk, selectStatus } from '@splitsoftware/splitio-redux';

// initSplitSdk action creator would return a promise. If the SDK is ready already the promise will be resolved by this time.
store.dispatch(initSplitSdk({ config: sdkConfig }));

// Use the selector to get the isReady flag from the state.
const { isReady } = selectStatus(store.getState().splitio);
```
  </TabItem>
</Tabs>

The `getTreatments` action creator evaluates feature flag treatments for the given `splitNames` (array of feature flag names) and `key` (e.g., user or account ID) values. In the browser, the key value is taken from the configuration and bound to the client, so you don't need to pass it here unless you need to change the key.

If the SDK is not ready when you dispatch the `getTreatments` action, the library queues that evaluation and loads the result into the state once the `SDK_READY` event is emitted. If you happen to queue more than one evaluation for the same `splitName` and `key` the SDK will keep the latest set of attributes and evaluate only once. 

<Tabs
  values={[
    {label: 'Client side (browser)', value: 'browser'},
    {label: 'Server side (Node.js/SSR)', value: 'ssr'},
  ]}>
  <TabItem value="browser">

```javascript
import { getTreatments } from '@splitsoftware/splitio-redux';

// Dispatch action to evaluate and load treatments for a feature flag. The key used is the one passed in the config.
store.dispatch(getTreatments({ splitNames: ['feature_flag_1'] }));
// Or a list of feature flags.
store.dispatch(getTreatments({ splitNames: ['feature_flag_2', 'feature_flag_3'] }));
```
  </TabItem>
  <TabItem value="ssr">
```javascript
import { getTreatments } from '@splitsoftware/splitio-redux';

// Dispatch action to evaluate and load treatments for a feature flag. In Node.js we need to provide the key on each getTreatments.
store.dispatch(getTreatments({ splitNames: ['feature_flag_1'], key: 'key' }));
// Or a list of feature flags.
store.dispatch(getTreatments({ splitNames: ['feature_flag_2', 'feature_flag_3'], key: 'key' }));
```
  </TabItem>
</Tabs>

After feature flag treatments are part of the state, use the `splitio.treatments` slice of state or our selectors to access the feature flag evaluation results and write the code for the different treatments that you defined in the Split user interface. Remember to handle the client returning control in your code. 


<Tabs
  values={[
    {label: 'Client side (browser)', value: 'browser'},
    {label: 'Server side (Node.js/SSR)', value: 'ssr'},
  ]}>
  <TabItem value="browser">

```javascript
// Import treatment value selector.
import { selectTreatmentAndStatus } from '@splitsoftware/splitio-redux');

// Get the treatment corresponding to the key bound to the main client for feature_flag_1 feature flag.
const { treatment, isReady } = selectTreatmentAndStatus(store.getState().splitio, 'feature_flag_1');

if (isReady) {
  if (treatment === 'on') {
    // insert on code here
  } else if (treatment === 'off') {
    // insert off code here
  } else {
    // insert control code here
  }
}

// Alternatively you could access the treatments directly from the store or your own custom selectors.
const splitTreatments = store.getState().splitio.treatments;
const treatment = splitTreatments['key']['feature_flag_1'].treatment;
```
  </TabItem>
  <TabItem value="ssr">
```javascript
// Import treatment value selector.
import { selectTreatmentAndStatus } from '@splitsoftware/splitio-redux';

// Get the treatment corresponding to the key of value 'key' for feature_flag_1 feature flag.
const { treatment } = selectTreatmentAndStatus(store.getState().splitio, 'feature_flag_1', 'key');

if (treatment === 'on') {
  // insert on code here
} else if (treatment === 'off') {
  // insert off code here
} else {
  // insert control code here
}

// Alternatively you can access the treatments directly from the store or your own custom selectors.
const splitTreatments = store.getState().splitio.treatments;
const treatment = splitTreatments['key']['feature_flag_1'].treatment;
```
  </TabItem>
</Tabs>

Note that these treatments won't be updated automatically when there is a change to your feature flags or segments. This is to avoid flickering. If you want to react to SDK events, see the [Subscribe to events](#subscribe-to-events) section below.

### More SDK features

<DocCardList />