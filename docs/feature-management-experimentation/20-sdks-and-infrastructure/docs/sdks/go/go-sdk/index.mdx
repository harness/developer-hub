---
title: FME Go SDK
sidebar_label: Go SDK
description: Golang developer reference for working with FME on the server side
---

import DocCardList from '@theme/DocCardList';

This guide provides detailed information about our Go SDK. All of our SDKs are open source. Go to our [Go SDK GitHub repository](https://github.com/splitio/go-client) to learn more.

## Language support

The Go SDK supports Go language version 1.18 and above. 

## Initialization
 
### SDK architecture

The Go SDK can run in three different modes to fit in different infrastructure configurations.

* **in-memory-standalone:** The default (if no mode is specified) and most straightforward operation mode uses an in-memory storage to keep feature flags, segments, and queued impressions/metrics, as well as its own synchronization tasks that periodically keep feature flags and segments up to date, while flushing impressions and metrics to the Split backend.
* **redis-consumer:** This mode uses Redis as a broker to retrieve feature flags and segments and store impressions and metrics. It also requires the [Split Synchronizer](https://help.split.io/hc/en-us/articles/360019686092) to be running in the background, populating Redis with segments and feature flags, and flushing impressions and metrics to the Split backend. This mode is useful if you have multiple instances of Split's SDKs running (either in the same or a different language) and want to have a single synchronization point in your infrastructure.
* **localhost:** This mode should be used to stub the Split service when running local tests or development processes. It parses a file (either one specified by the user or `$HOME/.splits`) that defines feature flags and treatments to provide the developer with a predictable result of running `Treatment()` calls. 

### 1. Installing the SDK into your Go environment

Since version 6, the Go SDK uses modules to handle all dependencies including itself, and due to semantic import versioning, both `dep` and bare-bones `go-get` are deprecated. To start using our SDK with modules, update your `go.mod` file as follows:

```go title="go.mod"
require "github.com/splitio/go-client/v6 v6.7.0"
```

And update the import paths in your application to use the `v6` package suffix as follows:

```go title="example.go
import "github.com/splitio/go-client/v6/splitio/client
```

```go title="Go get"
go get github.com/splitio/go-client/v6@v6.7.0
```

:::warning[If using Synchronizer with Redis - Synchronizer 2.x required after SDK Version 5.0.0]
Since version 2.0.0 of the split-synchronizer, we use a more efficient scheme to store impressions in Redis. This approach is faster and easier on your Redis instances, since it yields better throughput of impressions to the backend. If you use this SDK with the synchronizer in Redis or Proxy mode, you will need the newest versions of our Split synchronizer. It is recommended that once you're using SDK versions compatible with Split-Sync 2.0 on all your applications pointing to the Redis instance maintained by the Split-Sync, you disable backwards compatibility (this is as easy as changing a parameter to `true` on the JSON config or an environment variable to `on` if you're using the docker image).
:::

### 2. Import the SDK into your project

You can import the SDK into your project as shown below.

```go title="go-client > v6.7.0"
import (
	"github.com/splitio/go-client/v6/splitio/client"
	"github.com/splitio/go-client/v6/splitio/conf"
)
```

:::info[Using a wrapper]
Starting on version v6.0.0, every breaking change will require that you update your imports in cases where the SDK is used across multiple files.
It is recommended to create a wrapper that keeps it encapsulated. The package/file should be responsible for instantiating a single instance and exposing its functionality.
:::

### 3. Instantiate the SDK and create a new Split client

:::danger[If upgrading an existing SDK - Block until ready changes]
Starting version 4.0.0, cfg.BlockUntilReady is deprecated and migrated to the following implementation:
* Call `SplitClient#BlockUntilReady(int)` or `SplitManager#BlockUntilReady(int)`.
:::

When the SDK is instantiated in `inmemory-standalone` operation mode, it kicks off background tasks to update an in-memory or Redis cache.

This process can take up to a few hundred milliseconds depending on the size of data. If the SDK is asked to evaluate which treatment to show to a customer for a specific feature flag while it is in this intermediate state, it may not have the data necessary to run the evaluation. In this circumstance, the SDK does not fail, but instead returns [the control treatment](https://help.split.io/hc/en-us/articles/360020528072-Control-treatment).

To make sure the SDK is properly loaded before asking it for a treatment, you need to block until the SDK is ready. You can block by using the `BlockUntilReady(int)` method as part of the instantiation process of the SDK client as shown below. Do this as a part of the startup sequence of your application.

Instantiating two (or more) different factories results in multiple instances of synchronization tasks, so you can have different instances of the SDK with different SDK Keys running within a single application.

In the most common scenario, you should instantiate and reuse a single Split factory throughout your application.

Configure the SDK with the SDK key for the Split environment that you would like to access. The SDK key is available in the Split user interface, on your Admin settings page, API keys section. Select a server-side SDK API key. See [API keys](https://help.split.io/hc/en-us/articles/360019916211) to learn more.

```go title="Go"
func main() {
  	cfg := conf.Default()
	factory, err := client.NewSplitFactory("YOUR_SDK_KEY", cfg)
	if err != nil {
		fmt.Printf("SDK init error: %s\n", err)
		return
	}

	splitClient := factory.Client()
	err = splitClient.BlockUntilReady(10)
	if err != nil {
		fmt.Printf("SDK timeout: %s\n", err)
		return
	}
	// ...
}
```

Now you can start asking the SDK to evaluate treatments for your customers.

## Using the SDK
 
### Basic use

After you instantiate the SDK client, you can start using the client's `Treatment` method to decide what version of your feature flags your customers are served. The method requires the `FEATURE_FLAG_NAME` attribute that you want to ask for a treatment and a unique `key` attribute that corresponds to the end user that you are serving the feature flag to.

Then use an if-else-if block as shown below and insert the code for the different treatments that you defined in the Split user interface. Remember the final else branch in your code to handle the client returning the [control treatment](https://help.split.io/hc/en-us/articles/360020528072-Control-treatment).

```go title="Go"
// The key here represents the ID of the user/account/etc you're trying to evaluate a treatment for
treatment := splitClient.Treatment("KEY", "FEATURE_FLAG_NAME", nil)
if treatment == "on" {
  // insert code here to show on treatment
} else if treatment == "off" {
  // insert code here to show off treatment 
} else {
  // insert your control treatment code here
}
```

The arguments for the `Treatment()` call are:

* **key:** Either a string or a compound key that includes to strings. The matching key is used for evaluation purposes, and the bucketing key is used to determine the treatment based on the percentages specified in the feature flag creation user interface.
* **featureFlagName:** The name of the feature flag you are evaluating.
* **attributes:** A `map[string]interface{}` element that contains the attributes that are used by specific conditions that rely on information other than the key for matching purposes.

### More SDK features

<DocCardList />