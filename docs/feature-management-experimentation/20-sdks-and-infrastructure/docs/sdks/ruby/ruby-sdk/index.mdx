---
title: FME Ruby SDK
sidebar_label: Ruby SDK
description: Ruby and Ruby on Rails developer reference for working with FME on the server side
---

import DocCardList from '@theme/DocCardList';

This guide provides detailed information about our Ruby SDK. All of our SDKs are open source. Go to our [Ruby SDK GitHub repository](https://github.com/splitio/ruby-client) to learn more.

## Initialization

### 1. Import the SDK into your project

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
  values={[
    {label: 'Ruby', value: 'ruby'},
    {label: 'JRuby', value: 'jruby'},
  ]}>
  <TabItem value="ruby">
```ruby
gem install splitclient-rb -v '~> 8.5.0'
```
  </TabItem>
  <TabItem value="jruby">
```ruby
gem install splitclient-rb -v '~> 8.5.0'
```
  </TabItem>
</Tabs>

:::warning[If using Synchronizer with Redis - Synchronizer 2.x required after SDK Version 3.x]

Since version 2.0.0 of the split-synchronizer, we use a more efficient scheme to store impressions in Redis. This approach is faster and easier on your Redis instances, since it yields better throughput of impressions to the backend. If you use this SDK with the Synchronizer in Redis or Proxy mode, you need the newest versions of our Split Synchronizer. We recommend that once you're using SDK versions compatible with Split-Sync 2.0 on all your applications pointing to the redis instance maintained by the Split-Sync, you disable backwards compatibility. This is as easy as changing a parameter to `true` on the JSON config or an environment variable to `on` if you're using the docker image.
:::

### 2. Instantiate the SDK and create a new Split client

When the SDK is instantiated, it starts background tasks to update an in-memory cache with small amounts of data fetched from Split servers. This process can take up to a few hundred milliseconds, depending on the size of data. If the SDK is asked to evaluate which treatment to show to a customer for a specific feature flag while its in this intermediate state, it may not have the data necessary to run the evaluation. In this case, the SDK does not fail, rather, it returns [the control treatment](https://help.split.io/hc/en-us/articles/360020528072-Control-treatment).

To make sure the SDK is properly loaded before asking it for a treatment, block it until the SDK is ready. You can do this by using the `block_until_ready` method of the Split Client (or Manager) as part of the instantiation process of the SDK as shown below. Do this as a part of the startup sequence of your application.

We recommend instantiating the Split factory once as a singleton and reusing it throughout your application.

Configure the SDK with the SDK key for the Split environment that you would like to access. The SDK key is available in the Split user interface, on your Admin settings page, API keys section. Select a server-side SDK API key. See [API keys](https://help.split.io/hc/en-us/articles/360019916211) to learn more.

```ruby title="Ruby"
require 'splitclient-rb'

split_factory = SplitIoClient::SplitFactory.new('YOUR_SDK_KEY')
split_client = split_factory.client

begin
  split_client.block_until_ready
rescue SplitIoClient::SDKBlockerTimeoutExpiredException
  puts 'SDK is not ready. Decide whether to continue or abort execution'
end
```

### Configure the SDK for use with Rails

Our SDK is compatible with Ruby on Rails. There are a few extra steps for the initialization. You can configure the SDK to work with Rails with the code snippet below.

```ruby title="Ruby"
split_factory = SplitIoClient::SplitFactory.new('YOUR_SDK_KEY')
Rails.configuration.split_client = split_factory.client
```

To access the SDK client in your controllers, use the code snippet below:

```ruby title="Ruby"
Rails.application.config.split_client
```

Now you can start asking the SDK to evaluate treatments for your customers.

### SDK Server Compatibility

The Split Ruby SDK has been tested as a standalone app using the following web servers:
* Puma
* Passenger
* Unicorn

For other setups, contact [support@split.io](mailto:support@split.io).

#### Unicorn and Puma in cluster mode

**Note:** This is only applicable when using "memory storage".

During the start of your application, the SDK spawns multiple threads. Each thread has an infinite loop inside, which is used to fetch feature flags/segments or send impressions/events to the Split service continuously. When using Unicorn or Puma in cluster mode (i.e. with `workers` > 0) the application server will spawn multiple child processes, but they won't recreate the threads that existed in the parent process. So, if your application is running in Unicorn or Puma in cluster mode you need to make two small extra steps.

For both servers, you need to have the following line in your `config/initializers/splitclient.rb`:

```ruby
Rails.configuration.split_factory = factory
```

Find below the specific setup for each one:

#### Unicorn

If you’re using Unicorn in cluster mode, you’ll need to include these lines in your Unicorn config (likely `config/unicorn.rb`):

```ruby
before_fork do |server, worker|
  ## keep your existing before_fork code if any
  Rails.configuration.split_factory.stop!
end
after_fork do |server, worker|
  ## keep your existing after_fork code if any
  Rails.configuration.split_factory.resume!
end
```

#### Puma

If using Puma in cluster mode, add these lines to your Puma config (likely `config/puma.rb`):

```ruby
before_fork do
  ## keep your existing before_fork code if any
  Rails.configuration.split_factory.stop!
end
on_worker_boot do
  ## keep your existing on_worker_boot code if any
  Rails.configuration.split_factory.resume!
end
```

By doing the above, the SDK recreates the threads for each new worker and prevents the master process (that doesn't handle requests) from needlessly querying the Split service.

:::danger[Server spawning method]
If you are running NGINX with `thread_spawn_method = 'smart'`, use our Redis integration with the [Split Synchronizer](https://help.split.io/hc/en-us/articles/360019686092-Split-synchronizer) or contact [support@split.io](mailto:support@split.io) for alternatives to run Split.
:::

## Using the SDK

### Basic use

After you instantiate the SDK client, you can start using the `get_Treatment` method of the SDK client to decide what version of your features your customers are served. The method requires the `FEATURE_FLAG_NAME` attribute that you want to ask for a treatment and a unique `KEY` attribute that corresponds to the end user that you want to serve the feature to.

From there, you simply need to use an if-else-if block as shown below and insert the code for the different treatments that you defined in the Split user interface. Remember the final else branch in your code to handle the client returning [the control treatment](https://help.split.io/hc/en-us/articles/360020528072-Control-treatment).

```ruby title="Ruby"
## The key here represents the ID of the user, account, etc. you're trying to evaluate a treatment for
treatment = split_client.get_treatment('KEY', 'FEATURE_FLAG_NAME');

if treatment == 'on'
  ## insert code here to show on treatment
elsif treatment == 'off'
  ## insert code here to show off treatment
else
  ## insert your control treatment code here
end
```

##### More SDK features

<DocCardList />