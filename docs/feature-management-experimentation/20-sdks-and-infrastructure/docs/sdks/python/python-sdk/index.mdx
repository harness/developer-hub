---
title: FME Python SDK
sidebar_label: Python SDK
description: Python developer reference for working with FME on the server side
---

import DocCardList from '@theme/DocCardList';

This guide provides detailed information about our Python SDK. All of our SDKs are open source. Go to our [Python SDK GitHub repository](https://github.com/splitio/python-client) to learn more.

## Language support

The Python SDK supports Python 3 (3.7.16 or later).

## Multi-thread, multi-process and asyncio modes support

One of Python's great built-in features is the ability to parallelize your code to optimize the execution-performance of any module. You can implement your project in a multi-threaded, multi-process or asyncio mode, depending on what works best for you and your team.

Please note, multiple processes in Python are unable to share memory space, so the setup and instantiation process is different for each mode.

Jump to the setup process for the mode your application is built in:

* [Multi-threaded SDK initialization](#initialization-multi-threaded-mode)
* [asyncio SDK initialization](#initialization-asyncio-mode)
* [Multi-process SDK initialization](#initialization-multi-process-mode)

(Note: Django projects are multi-process by default)

## Initialization: Multi-threaded mode

Set up Split in your code base with two simple steps.

### 1. Import the SDK into your project using pip

```bash title="Shell"
pip install 'splitio_client[cpphash]==10.2.0'
```

### 2. Instantiate the SDK and create a new split client

:::danger[If upgrading an existing SDK - Block until ready changes]
Starting in version `8.0.0`, readiness has been migrated to a two part implementation. See below for syntax changes you must make if upgrading your SDK to the newest version.
:::

When the SDK is instantiated in `in-memory` mode, it kicks off background tasks to update an in-memory cache with small amounts of data fetched from Split servers. This process can take up to a few hundred milliseconds depending on the size of data. If the SDK is asked to evaluate which treatment to show to a customer for a specific feature flag while its in this intermediate state, it may not have the data necessary to run the evaluation. In this case, the SDK doesn't fail, rather, it returns [the control treatment](https://help.split.io/hc/en-us/articles/360020528072-Control-treatment).

To make sure the SDK is properly loaded before asking it for a treatment, block until the SDK is ready.
Since version `8.0.0` This is done by calling the `.block_until_ready()` method in the factory object.
This method also accepts a maximum time (in seconds or fractions of it) to wait until the SDK is ready, or throw an exception in case it's not.

We recommend instantiating the Split factory once as a singleton and reusing it throughout your application.

Configure the SDK with the SDK key for the Split environment that you would like to access. The SDK key is available in the Split user interface, on your Admin settings page, API keys section. Select a server-side SDK API key. See [API keys](https://help.split.io/hc/en-us/articles/360019916211) to learn more.

```python title="Python"
from splitio import get_factory
from splitio.exceptions import TimeoutException

factory = get_factory('YOUR_SDK_KEY')
try:
    factory.block_until_ready(5) ## wait up to 5 seconds
except TimeoutException:
    ## Now the user can choose whether to abort the whole execution, or just keep going
    ## without a ready client, which if configured properly, should become ready at some point.
    pass
split = factory.client()
```

Now you can start asking the SDK to evaluate treatments for your customers.

## Initialization: asyncio mode

Python's asyncio library had gather lot of attention and support and provides many advantages to multi-threaded programming especially in I/O operations, checkout the [official doc](https://docs.python.org/3/library/asyncio.html) for more info.

Set up Split in your code base with two simple steps.

### 1. Import the SDK into your project using pip

```bash title="Shell"
pip install 'splitio_client[cpphash,asyncio]==10.2.0'
```

### 2. Instantiate the SDK and create a new split client

:::danger[asyncio support]
Starting in version `10.0.0`, SDK support asyncio library, this required a breaking change to upgrade the python supported version to be 3.7.16 or later.
:::

:::info[asyncio support]
When using the SDK, regardless if the mode is asyncio or Multi-threaded, all the public SDK API are identical, with only one exception; when initializing the factory.
:::

Similar to Multi-threaded mode, when the SDK is instantiated in `in-memory`, it kicks off background asyncio tasks to update an in-memory cache with small amounts of data fetched from Split servers. To make sure the SDK cache is properly loaded before asking it for a treatment, utilize `block_until_ready()` method.

We recommend instantiating the SDK once as a singleton and reusing it throughout your application.

Use the code snippet below and plug in your API key. The API key is available on your **Organization Settings** page, on the **APIs** tab. The API key is of type `sdk`. For more information, see [Understanding API Keys](https://help.split.io/hc/en-us/articles/360019916211-API-keys).

```python title="Python"
from splitio import get_factory_async
from splitio.exceptions import TimeoutException

async def main():
    factory = await get_factory_async('YOUR_SDK_KEY')
    try:
        await factory.block_until_ready(5) ## wait up to 5 seconds
    except TimeoutException:
        ## Now the user can choose whether to abort the whole execution, or just keep going
        ## without a ready client, which if configured properly, should become ready at some point.
        pass
    split = factory.client()

loop = asyncio.new_event_loop()
loop.run_until_complete(main())
```

For the following sections, please lookup the `asyncio` tab in each code example block.

## Initialization: Multi-process mode

There are a few extra steps for setting up our SDK with Python in multi-process mode, described below. Before hopping into the details, we will quickly review the multi-process mode setup differences.

### SDK architecture

When the application is run in a server that spawns multiple processes (workers) to handle HTTP requests, all of them need to access fetched feature flags and segments as well as queuing up impressions and events. Since processes cannot access each other's memory, using the standalone operation mode will result in several sets of synchronisation tasks (threads) doing the same job (at least one per http worker - possibly more, since workers are often restarted).
To avoid this scenario, the Split.IO SDK for Python supports an alternative operation mode, which uses an external tool called `Split-Synchronizer` and a `redis` cache. Our synchronization tool is responsible for maintaining the split data updated and flushing impressions, events and metrics to the split servers.
If you are using a preforked-type server such as uWSGI or GUnicorn, we also offer a series of methods that can be attached to the server's "post-fork" hooks in order to ensure synchronization runs properly on the worker process after the master is forked.

The previously mentioned approaches are described in depth below:

* [Redis cache and client setup](#redis-cache-and-client-setup)
* [Preforked client setup](#preforked-client-setup)

### Redis cache and client setup

Before you get started with the cache, download the correct version of Redis to your machine. Our SDK Redis integration requires a Redis version `2.10.5` or later. Also want to make sure to start your Redis server. Refer to the [Redis documentation](https://redis.io/topics/quickstart) for help. After that, there are a few more steps to set up the cache with Redis.

#### 1. Install the Split SDK into your project

Use `pip install` to install the SDK. Note that the package is different for standard Python and for Django, as shown below.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
  groupId="python-sdk-mode"
  values={[
    {label: 'Multi-threaded', value: 'multi'},
    {label: 'asyncio', value: 'asyncio'},
    {label: 'Django', value: 'django'},
  ]}>
  <TabItem value="multi">
```bash
pip install 'splitio_client[redis,cpphash]==10.2.0'
```
  </TabItem>
  <TabItem value="asyncio">
```bash
pip install 'splitio_client[redis,cpphash,asyncio]==10.2.0'
```
  </TabItem>
  <TabItem value="django">
```bash
pip install django_splitio[redis]==2.4.0
```
  </TabItem>
</Tabs>

:::warning[If using Synchronizer with Redis - Synchronizer 2.x required for SDK Version `7.0` and onwards]
Since version `2.0.0` of the split-synchronizer, we use a more efficient scheme to store impressions in Redis. This approach is faster and easier on your Redis instances, since it yields better throughput of impressions to the backend. If you use this SDK with the Synchronizer in Redis or Proxy mode, you will need the newest versions of our Split Synchronizer. It is recommended that once you're using SDK versions compatible with Split-Sync 2.0 on all your applications pointing to the redis instance maintained by the Split-Sync, you disable backwards compatibility (this is as easy as changing a parameter to `true` on the JSON config or an environment variable to `on` if you're using the docker image).
:::

#### 2. Set up the Split Synchronizer

Set up the [Split Synchronizer](https://help.split.io/hc/en-us/articles/360019686092) to sync data to a Redis cache. Follow the steps in the [set up article](https://help.split.io/hc/en-us/articles/360019686092), then come back to this doc and go to step 3 to instantiate the client, below.

#### 3. Instantiate the SDK client with Redis enabled

If you are using Django, there is one extra step to add `django_splitio` to `INSTALLED_APPS` in your Django settings and add a SPLITIO dictionary in the Django settings. Input your own SDK key in for `YOUR_SDK_KEY`.

To instantiate the SDK client, copy and paste the code snippet below into your code base where you want to use Split to roll out your feature flag. Again, note that the syntax is different for standard Python and for Django.

<Tabs
  groupId="python-sdk-mode"
  values={[
    {label: 'Multi-threaded', value: 'multi'},
    {label: 'asyncio', value: 'asyncio'},
    {label: 'Django', value: 'django'},
  ]}>
  <TabItem value="multi">
```python
from splitio import get_factory

config = {
  'redisHost' : 'localhost',
  'redisPort' : 6379,
  'redisDb' : 0,
  'redisPassword' : 'somePassword',
  ## if the user access is not the default 'root' user, inlcude parameter below
  'redisUsername' : 'username',
  ## if you've set a redis prefix also include that in the config
  'redisPrefix' : 'your prefix that you defined'
}

factory = get_factory('YOUR_SDK_KEY', config=config)
split = factory.client()
```
  </TabItem>
  <TabItem value="asyncio">
```python
from splitio import get_factory_async

async def main():
    config = {
    'redisHost' : 'localhost',
    'redisPort' : 6379,
    'redisDb' : 0,
    'redisPassword' : 'somePassword',
    ## if the user access is not the default 'root' user, inlcude parameter below
    'redisUsername' : 'username',
    ## if you've set a redis prefix also include that in the config
    'redisPrefix' : 'your prefix that you defined'
    }

    factory = await get_factory_async('YOUR_SDK_KEY', config=config)
    split = factory.client()

loop = asyncio.new_event_loop()
loop.run_until_complete(main())
```
  </TabItem>
  <TabItem value="django">
```python
## In your django config:
INSTALLED_APPS = (
        ...
        'django_splitio',
        ...
    )

SPLITIO = {
    'apiKey': 'YOUR_SDK_KEY',
    'labelsEnabled': True,
    'redisHost': 'localhost',
    'redisPort': 6379,
    'redisDb': 0,
    'redisPassword': 'somePassword'
    ## if the user access is not the default 'root' user, inlcude parameter below
    'redisUsername' : 'username',
    ## if you've set a redis prefix also include that in the config
    'redisPrefix' : 'your prefix that you defined'
}

## -------------------------

## in any module where the sdk is to be used.
from django_splitio import get_factory

factory = get_factory()
client = factory.client()
```
  </TabItem>
</Tabs>

Now you can start asking the SDK to evaluate treatments for your customers.

#### Redis Sentinel

The SDK also supports Redis with Sentinel (v2) replication. The client can be configured to operate with single master/multiple slaves to provide high availability. The current version of Sentinel is `2`. A stable release of Sentinel has been shipped since Redis `2.8`. For further information about Sentinel, refer to the [Sentinel documentation](https://redis.io/topics/sentinel).

Use the following configuration for Redis in Sentinel mode.

| **Variable** | **Type** | **Description** |
| --- | --- | --- |
| redisSentinels | array | The list of sentinels for replication service. |
| redisMasterService | string | The name of master service. |

<Tabs
  groupId="python-sdk-mode"
  values={[
    {label: 'Multi-threaded', value: 'multi'},
    {label: 'asyncio', value: 'asyncio'},
    {label: 'Django', value: 'django'},
  ]}>
  <TabItem value="multi">
```python
from splitio import get_factory

config = {
    'redisDb': 0,
    'redisPrefix': '',
    'redisSentinels': [('SENTINEL_HOST_1', SENTINEL_PORT_1), ('SENTINEL_HOST_2', SENTINEL_PORT_2), ('SENTINEL_HOST_3', SENTINEL_PORT_3)],
    'redisMasterService': 'SERVICE_MASTER_NAME',
    'redisSocketTimeout': 5
}

factory = get_factory('SDK_KEY', config=config)
split = factory.client()
```
  </TabItem>
  <TabItem value="asyncio">
```python
from splitio import get_factory_async

async def main():
    config = {
        'redisDb': 0,
        'redisPrefix': '',
        'redisSentinels': [('SENTINEL_HOST_1', SENTINEL_PORT_1), ('SENTINEL_HOST_2', SENTINEL_PORT_2), ('SENTINEL_HOST_3', SENTINEL_PORT_3)],
        'redisMasterService': 'SERVICE_MASTER_NAME',
        'redisSocketTimeout': 5
    }

    factory = await get_factory_async('SDK_KEY', config=config)
    split = factory.client()

loop = asyncio.new_event_loop()
loop.run_until_complete(main())
```
  </TabItem>
  <TabItem value="django">
```python
## In your django config:
INSTALLED_APPS = (
        ...
        'django_splitio',
        ...
    )

SPLITIO = {
    'apiKey': 'YOUR_SDK_KEY',
    'labelsEnabled': True,
    'redisSentinels': [('SENTINEL_HOST_1', SENTINEL_PORT_1),   ('SENTINEL_HOST_2', SENTINEL_PORT_2), ('SENTINEL_HOST_3', SENTINEL_PORT_3)],
    'redisMasterService': 'SERVICE_MASTER_NAME',
    'redisDb': 0,
    'redisPassword': 'somePassword',
    'redisSocketTimeout': 5
    ## if the user access is not the default 'root' user, inlcude parameter below
    'redisUsername' : 'username'
}

## -------------------------

## in any module where the sdk is to be used.
from django_splitio import get_factory

factory = get_factory()
client = factory.client()
```
  </TabItem>
</Tabs>

#### Redis Cluster

This functionality is currently not supported for this SDK, but is planned for a future release. Subscribe to our [release notes](https://www.split.io/releases) for updates.

### Preforked client setup

Since version `8.4.0` we added support for running our SDK in standalone mode in preforked multiprocess servers. With this feature you can take advantage of using Split in preforking servers such as GUnicorn or uWSGI and attaching it to the `postfork` hooks. This can yield significant performance improvements in terms of memory in comparison to use lazy-style initialization and greatly reduced evaluation time in comparison to use Redis + Split Synchronizer approach at the expense of CPU and BG network traffic.
There are two main steps for initializating the Split SDK by using hooks:
1. `preforkedInitialization`: this is a new configuration option that will tell the SDK that it should initiate the SDK in master mode and it will not start polling nor streaming.
2. `factory.resume()`: this is a new method provided by Split Factory that should be executed on newly forked http worker processes in order to resume synchronisation.

:::warning
Preforked client is not supported in asyncio mode.
:::

#### Example using uWSGI preforked server

#### Adding postfork handler

There are a few extra steps to set up SDK with `postfork` option.
1. Importing the `uwsgidecorators` module for handling hooks.
2. Set `preforkedInitialization` as true in the sdk configs.
3. Add and use the `postfork` decorator.
5. Call `factory.resume()` method to resume Split tasks on each forked child process.

:::tip
Make sure to add the parameter `--enable-threads` to enable multi-threading when starting the UWSGI app server. While Python SDK does support UWSGI app server in process based mode, for the SDK to synchronize with Split cloud, you need to enable the multi-threading option, as the background threads perform the synching task. For example:

```bash title="Shell"
uwsgi --http :8080 --chdir /var/app --wsgi-file ${WSGI_PATH} ${UWSGI_MODULE} --master
--processes ${UWSGI_NUM_PROCESSES} --uid ${UWSGI_UID} --gid ${UWSGI_GID} -t ${UWSGI_TIMEOUT}
--http-keepalive --add-header ${UWSGI_HEADERS} --buffer-size ${UWSGI_BUFFER_SIZE}
--enable-threads
```
:::

<Tabs
  values={[
    {label: 'Standard Python', value: 'multi'},
    {label: 'Django', value: 'django'},
  ]}>
  <TabItem value="multi">
```python
import logging
import uwsgi
from uwsgidecorators import postfork  ## Step 1


logging.basicConfig(level=logging.DEBUG)

## more code ...

SPLIT = get_factory(
    'YOUR_SDK_KEY',
    config={
        'preforkedInitialization': True,  ## Step 2
    },
)


@postfork ## Step 3
def post_fork_execution():
    SPLIT.resume()  ## Step 4
    SPLIT.block_until_ready(5)

## more code ...
```
  </TabItem>
  <TabItem value="django">
```python
## In your django config:
INSTALLED_APPS = (
        ...
        'django_splitio',
        ...
    )
 SPLITIO = {
        'apiKey': 'YOUR_SDK_KEY',
        'preforkedInitialization': True ## Step 2
    }
## -------------------------
## in setup Split module
from django_splitio import get_factory


global SPLIT


def setup():
    global SPLIT
    if 'SPLIT' in globals():
        return
    SPLIT = get_factory()

## in master module
import logging
import uwsgi
from uwsgidecorators import postfork  ## Step 1
from django_splitio_testapp.split_wrapper import setup


logging.basicConfig(level=logging.DEBUG)
setup()


@postfork ## Step 3
def post_fork():
    from django_splitio_testapp.split_wrapper import SPLIT
    SPLIT.resume() ## Step 4
    SPLIT.block_until_ready(5)

## more code ...

```
  </TabItem>
</Tabs>

For further reading about uwsgi decorators and postfork you can take a look at the [official documentation](https://uwsgi-docs.readthedocs.io/en/latest/PythonDecorators.html#uwsgidecorators.postfork)

## Using the SDK

### Basic use

After you instantiate the SDK client, you can start using the `get_treatment` method of the SDK client to decide what version of your feature flags your customers are served. The method requires the `FEATURE_FLAG_NAME` attribute that you want to ask for a treatment and a unique `key` attribute that corresponds to the end user that you want to serve the feature to.

From there, you simply need to use an if-else-if block as shown below and insert the code for the different treatments that you defined in the Split UI. Remember the final else branch in your code to handle the client returning [the control treatment](https://help.split.io/hc/en-us/articles/360020528072-Control-treatment).

<Tabs
  values={[
    {label: 'Multi-threaded', value: 'multi'},
    {label: 'asyncio', value: 'asyncio'},
  ]}>
  <TabItem value="multi">
```python
## The key here represents the ID of the user/account/etc you're trying to evaluate a treatment for
treatment = split.get_treatment('key', 'FEATURE_FLAG_NAME')

if treatment == "on":
    ## insert code here to show on treatment
elif treatment == "off":
    ## insert code here to show off treatment
else:
    ## insert your control treatment code here
```
  </TabItem>
  <TabItem value="asyncio">
```python
## The key here represents the ID of the user/account/etc you're trying to evaluate a treatment for
treatment = await split.get_treatment('key', 'FEATURE_FLAG_NAME')

if treatment == "on":
    ## insert code here to show on treatment
elif treatment == "off":
    ## insert code here to show off treatment
else:
    ## insert your control treatment code here
```
  </TabItem>
</Tabs>

:::info[key should be String]
If the `key` attribute is something other than `string`, Python SDK returns `CONTROL` after evaluation.
:::

#### More SDK features

<DocCardList />